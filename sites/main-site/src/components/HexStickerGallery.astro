---
import HexSticker from "./HexSticker.astro";

interface StickerData {
    imageUrl: string;
    alt: string;
    category: string;
    link?: string;
}

interface Props {
    stickers: StickerData[];
}

const { stickers } = Astro.props;

// Shuffle the stickers array for random display order
function shuffleArray(array: StickerData[]): StickerData[] {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

// Shuffle the stickers for random display
const shuffledStickers = shuffleArray(stickers);

// Keep track of categories for data attributes (useful for potential filtering)
const categories = [...new Set(stickers.map((sticker) => sticker.category))].sort();

// Group stickers by category
const stickersByCategory = categories.reduce(
    (acc, category) => {
        acc[category] = stickers.filter((sticker) => sticker.category === category);
        return acc;
    },
    {} as Record<string, StickerData[]>,
);

// Function to format category name for display
function formatCategoryName(category: string): string {
    // Special case for specific categories
    const specialCategories: Record<string, string> = {
        "pipelines": "Pipeline Stickers",
        "hackathons": "Hackathon Stickers",
        "hero": "Hero Stickers",
        "mentorships": "Mentorship Stickers",
        "teams": "Team Stickers"
    };

    if (specialCategories[category]) {
        return specialCategories[category];
    }

    // Default formatting for other categories
    return category
        .split("-")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
}
---

<div class="w-100 p-2">
    <div class="hex-gallery" id="hexGallery-all">
        {
            shuffledStickers.map((sticker) => (
                <HexSticker
                    imageUrl={sticker.imageUrl}
                    alt={sticker.alt}
                    category={sticker.category}
                    link={sticker.link}
                />
            ))
        }
    </div>
</div>

<style>
    .hex-gallery {
        --hex-size: 187.5px; /* Base size for large screens */
        --hex-margin: 0.5rem;
        position: relative;
        width: 100%;
        padding-bottom: 2rem; /* Consistent bottom padding */
        min-height: 50vh; /* Ensure gallery has enough height */
    }

    /* Responsive sizing for different screen sizes */
    @media (max-width: 1200px) {
        .hex-gallery {
            --hex-size: 175px;
        }
    }

    @media (max-width: 992px) {
        .hex-gallery {
            --hex-size: 150px;
        }
    }

    @media (max-width: 768px) {
        .hex-gallery {
            --hex-size: 125px;
        }
    }

    @media (max-width: 576px) {
        .hex-gallery {
            --hex-size: 100px;
        }
    }

    /* Hover effects for the gallery */
    .hex-gallery:hover .hex-container:not(:hover) {
        opacity: 0.55; /* Increased from 0.65 - even more contrast */
        filter: grayscale(0.4); /* Increased from 0.25 - more grayscale */
        transform: scale(0.9); /* Increased shrink effect from 0.94 */
        transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1); /* Smooth easing */
    }

    .hex-gallery .hex-container {
        transition:
            opacity 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), /* Bounce effect */
            filter 0.4s ease,
            transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), /* Bounce effect */
            box-shadow 0.4s ease;
        will-change: transform; /* Optimize for animations */
    }

    .hex-gallery .hex-container:hover {
        z-index: 10;
        transform: scale(1.18) rotate(3deg); /* Increased scale and rotation */
        filter: brightness(1.08) contrast(1.05) saturate(1.1); /* Enhanced brightness, contrast and saturation */
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3); /* Deeper shadow for more depth */
    }

    /* Add alternating tilt directions for more natural feel */
    .hex-gallery .hex-container:nth-child(even):hover {
        transform: scale(1.18) rotate(-3deg); /* Increased scale and rotation */
    }
</style>

<script>
    import { arrangeHexGrid, setupHexGridResizing, shouldRearrange } from "./hexGrid.js";

    let cleanupResizeListeners = [];
    let lastContainerWidths = new Map();

    function updateHexLayouts() {
        // Clean up previous resize listeners
        cleanupResizeListeners.forEach((cleanup) => cleanup());
        cleanupResizeListeners = [];

        // Get the hex gallery
        const hexGallery = document.querySelector(".hex-gallery");

        if (hexGallery) {
            const hexElements = Array.from(hexGallery.querySelectorAll(".hex-container"));

            if (hexElements.length > 0) {
                // Store initial width for comparison
                lastContainerWidths.set(hexGallery.id, hexGallery.clientWidth);

                // Add a class to enable CSS transitions
                hexElements.forEach((hex) => {
                    hex.classList.add("hex-positioned");
                });

                // Setup new hex grid with resize handling
                const cleanup = setupHexGridResizing(hexGallery, hexElements, {
                    spacing: 5, // Reduced spacing for a tight honeycomb pattern
                    startingRow: window.innerWidth < 576 ? 2 : 3, // Adjust starting row for mobile
                    minHexPerRow: 2, // Ensure at least 2 hexagons per row on small screens
                    transitionDuration: "0.4s", // Smooth transition duration
                    forceEvenRows: true, // Try to make rows more even
                });

                cleanupResizeListeners.push(cleanup);
            }
        }
    }

    // Initialize when the document is ready
    document.addEventListener("DOMContentLoaded", () => {
        if (document.readyState === "complete" || document.readyState === "interactive") {
            updateHexLayouts();
        } else {
            document.addEventListener("DOMContentLoaded", updateHexLayouts);
        }
    });

    // Handle orientation changes
    window.addEventListener("orientationchange", () => {
        // Small delay to ensure dimensions are updated after orientation change
        setTimeout(updateHexLayouts, 200);
    });

    // Handle window resize
    window.addEventListener("resize", () => {
        const hexGallery = document.querySelector(".hex-gallery");
        if (hexGallery && lastContainerWidths.has(hexGallery.id)) {
            const lastWidth = lastContainerWidths.get(hexGallery.id);
            const currentWidth = hexGallery.clientWidth;

            // Only rearrange if width changed significantly
            if (shouldRearrange(lastWidth, currentWidth)) {
                updateHexLayouts();
            }
        }
    });
</script>
