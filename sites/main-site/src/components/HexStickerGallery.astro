---
import HexSticker from "./HexSticker.astro";
import StickerModal from "./StickerModal.astro";

interface StickerData {
    imageUrl: string;
    alt: string;
    category: string;
    link?: string;
    description?: string;
}

interface Props {
    stickers: StickerData[];
}

const { stickers } = Astro.props;

// Get unique categories while preserving the order they first appear in the stickers array
const categories = [];
stickers.forEach((sticker) => {
    if (!categories.includes(sticker.category)) {
        categories.push(sticker.category);
    }
});

// Group stickers by category
const stickersByCategory = categories.reduce(
    (acc, category) => {
        acc[category] = stickers.filter((sticker) => sticker.category === category);
        return acc;
    },
    {} as Record<string, StickerData[]>,
);

// Function to format category name for display
function formatCategoryName(category: string): string {
    // Ensure all category names end with "Stickers"
    const baseName = category.charAt(0).toUpperCase() + category.slice(1);
    return baseName.endsWith("Stickers") ? baseName : `${baseName} Stickers`;
}
---

<div class="w-100 p-2">
    {
        categories.map((category, index) => (
            <div class="category-section" id={`category-${category}`}>
                <h2 class="category-heading mb-4">
                    {formatCategoryName(category)}
                    <a href="#top" class="back-to-top ms-2" title="Back to top">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-up-circle" viewBox="0 0 16 16">
                            <path fill-rule="evenodd" d="M1 8a7 7 0 1 0 14 0A7 7 0 0 0 1 8zm15 0A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-7.5 3.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V11.5z"/>
                        </svg>
                    </a>
                </h2>
                <div class="hex-gallery" id={`hexGallery-${category}`} data-category={category}>
                    {stickersByCategory[category].map((sticker) => (
                        <HexSticker
                            imageUrl={sticker.imageUrl}
                            alt={sticker.alt}
                            category={sticker.category}
                            link={sticker.link}
                            description={sticker.description}
                        />
                    ))}
                </div>
                {index < categories.length - 1 && (
                    <hr class="category-divider my-4" />
                )}
            </div>
        ))
    }
</div>

<!-- Include the sticker modal component -->
<StickerModal />

<style>
    .category-heading {
        text-align: center;
        font-size: 1.75rem;
        font-weight: 600;
        color: var(--bs-body-color);
        margin-top: 3rem; /* Consistent top margin */
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* First category heading should have less top margin */
    .category-section:first-child .category-heading {
        margin-top: 1rem;
    }

    .back-to-top {
        opacity: 0.5;
        transition: opacity 0.3s ease;
        color: var(--bs-body-color);
    }

    .back-to-top:hover {
        opacity: 1;
    }

    .category-divider {
        border-color: var(--bs-border-color);
        width: 50%;
        margin-left: auto;
        margin-right: auto;
    }

    .category-divider:last-child {
        display: none;
    }

    .hex-gallery {
        --hex-size: 187.5px; /* Base size for large screens */
        --hex-margin: 0.5rem;
        position: relative;
        width: 100%;
        padding-bottom: 2rem; /* Consistent bottom padding */
    }

    /* Responsive sizing for different screen sizes */
    @media (max-width: 1200px) {
        .hex-gallery {
            --hex-size: 175px;
        }
    }

    @media (max-width: 992px) {
        .hex-gallery {
            --hex-size: 150px;
        }
    }

    @media (max-width: 768px) {
        .hex-gallery {
            --hex-size: 125px;
        }
    }

    @media (max-width: 576px) {
        .hex-gallery {
            --hex-size: 100px;
        }
    }

    /* Hover effects for the gallery */
    .hex-gallery:hover .hex-container:not(:hover) {
        opacity: 0.55; /* Increased from 0.65 - even more contrast */
        filter: grayscale(0.4); /* Increased from 0.25 - more grayscale */
        transform: scale(0.9); /* Increased shrink effect from 0.94 */
        transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1); /* Smooth easing */
    }

    .hex-gallery .hex-container {
        transition:
            opacity 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), /* Bounce effect */
            filter 0.4s ease,
            transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), /* Bounce effect */
            box-shadow 0.4s ease;
        will-change: transform; /* Optimize for animations */
    }

    .hex-gallery .hex-container:hover {
        z-index: 10;
        transform: scale(1.18) rotate(3deg); /* Increased scale and rotation */
        filter: brightness(1.08) contrast(1.05) saturate(1.1); /* Enhanced brightness, contrast and saturation */
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3); /* Deeper shadow for more depth */
    }

    /* Add alternating tilt directions for more natural feel */
    .hex-gallery .hex-container:nth-child(even):hover {
        transform: scale(1.18) rotate(-3deg); /* Increased scale and rotation */
    }
</style>

<script>
    import { arrangeHexGrid, setupHexGridResizing, shouldRearrange } from "./hexGrid.js";

    let cleanupResizeListeners = [];
    let lastContainerWidths = new Map();

    function updateHexLayouts() {
        // Clean up previous resize listeners
        cleanupResizeListeners.forEach((cleanup) => cleanup());
        cleanupResizeListeners = [];

        // Get all hex galleries
        const hexGalleries = document.querySelectorAll(".hex-gallery");

        hexGalleries.forEach((gallery) => {
            const hexElements = Array.from(gallery.querySelectorAll(".hex-container"));

            if (hexElements.length > 0) {
                // Store initial width for comparison
                lastContainerWidths.set(gallery.id, gallery.clientWidth);

                // Add a class to enable CSS transitions
                hexElements.forEach((hex) => {
                    hex.classList.add("hex-positioned");
                });

                // Setup new hex grid with resize handling
                const cleanup = setupHexGridResizing(gallery, hexElements, {
                    spacing: 15, // Increased spacing between hexagons
                    startingRow: window.innerWidth < 576 ? 2 : 3, // Adjust starting row for mobile
                    minHexPerRow: 2, // Ensure at least 2 hexagons per row on small screens
                    transitionDuration: "0.4s", // Smooth transition duration
                    forceEvenRows: true, // Try to make rows more even
                });

                cleanupResizeListeners.push(cleanup);
            }
        });
    }

    // Use Intersection Observer to only initialize visible galleries
    function setupLazyInitialization() {
        const hexGalleries = document.querySelectorAll(".hex-gallery");

        if ("IntersectionObserver" in window) {
            const observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            const gallery = entry.target;
                            const hexElements = Array.from(gallery.querySelectorAll(".hex-container"));

                            if (hexElements.length > 0) {
                                // Setup hex grid for this gallery
                                const cleanup = setupHexGridResizing(gallery, hexElements, {
                                    spacing: 15, // Increased spacing between hexagons
                                    startingRow: window.innerWidth < 576 ? 2 : 3,
                                    minHexPerRow: 2,
                                    transitionDuration: "0.4s",
                                    forceEvenRows: true, // Try to make rows more even
                                });

                                cleanupResizeListeners.push(cleanup);

                                // Stop observing once initialized
                                observer.unobserve(gallery);
                            }
                        }
                    });
                },
                {
                    rootMargin: "200px", // Start loading before it's visible
                    threshold: 0.01,
                },
            );

            // Observe each gallery
            hexGalleries.forEach((gallery) => {
                observer.observe(gallery);
            });
        } else {
            // Fallback for browsers without IntersectionObserver
            updateHexLayouts();
        }
    }

    // Initialize when the document is ready
    document.addEventListener("DOMContentLoaded", () => {
        if (document.readyState === "complete" || document.readyState === "interactive") {
            setupLazyInitialization();
        } else {
            document.addEventListener("DOMContentLoaded", setupLazyInitialization);
        }
    });

    // Handle orientation changes
    window.addEventListener("orientationchange", () => {
        // Small delay to ensure dimensions are updated after orientation change
        setTimeout(updateHexLayouts, 200);
    });
</script>
